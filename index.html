<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bozo bot</title>
  <link rel="icon" type="image/x-icon" href="https://cdn.discordapp.com/channel-icons/1116010901586321448/93b9d536226c59aec9e50cb993321636.webp">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      cursor:none;
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background-color: #0d0d0d;
      color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
      background-size: cover;
      background-position: center;
      transition: background-image 0.5s ease;
    }

    #status, #trackInfo {
      margin: 30px;
      font-size: 4em;
      text-align: center;
      text-shadow: 1px 1px 4px #000;
    }

    #nowPlaying {
      display: none;
      text-align: center;
      max-width: 90%;
      width: 50%;
      z-index: 5;
      margin-bottom: 40px;
    }

    #trackDetails {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-bottom: 15px;
    }

    #trackDetails img {
      width: 80px;
      height: 80px;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.6);
      object-fit: cover;
    }

    #trackDetails div {
      text-align: left;
      max-width: 350px;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    #trackDetails div .title {
      font-weight: 600;
      font-size: 1.2em;
      margin-bottom: 0.2em;
      line-height: 1.3;
      word-break: break-word;
    }

    #trackDetails div .artist {
      font-weight: 400;
      font-size: 1em;
      opacity: 0.8;
      line-height: 1.3;
      word-break: break-word;
    }

    #visualizer {
      width: 100%;
      height: 100px;
      visibility: hidden;
      margin-top: 10%;
    }

    .bozoWatermark {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 2.5em;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #eebcff;
    }

    .timeDisplay {
      position: absolute;
      top: 20px;
      right: 20px;
      font-family: 'Poppins', sans-serif;
      font-size: 3.4em;
      color: #eebcff;
      text-shadow: 1px 1px 4px #000;
      text-align: right;
      line-height: 1.2;
    }

    .bozoWatermark img {
      width: 100px; /* adjust size as needed */
      height: 100px;
      -webkit-border-radius: 50px;
      -moz-border-radius: 50px;
    }

    canvas {
      width: 100%;
      height: 200px;
      border-radius: 16px;
      background: rgba(10, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <div class="bozoWatermark">
    <img src="https://cdn.discordapp.com/channel-icons/1116010901586321448/93b9d536226c59aec9e50cb993321636.webp?size=1024" alt="Icon">
    <span>BozoBOT</span>
  </div>
  <div class="timeDisplay" id="timeDisplay">
    <div id="dateDisplay"></div>
    <div id="clockDisplay"></div>
  </div>
  <div id="status">Connecting...</div>
  <div id="nowPlaying">
    <div id="trackDetails">
      <img id="albumArt" src="" alt="Album Art" />
      <div>
        <div class="title" id="title">Waiting for media...</div>
        <div class="artist" id="artist"></div>
      </div>
    </div>
    <div id="visualizer"><canvas id="canvas"></canvas></div>
  </div>

  <script>
    let ws, currentAudio, currentVideo, audioCtx, analyser, source, dataArray;
    let drawLoop;
    const statusEl = document.getElementById('status');
    const nowPlayingEl = document.getElementById('nowPlaying');
    const titleEl = document.getElementById('title');
    const artistEl = document.getElementById('artist');
    const albumArtEl = document.getElementById('albumArt');
    const visualizer = document.getElementById('visualizer');
    const canvas = document.getElementById('canvas');

    // Set canvas resolution properly
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) {
        // Canvas is not visible, skip sizing
        return false;
      }

      // Reset the canvas completely
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;

      // Get fresh context and scale it
      const ctx = canvas.getContext('2d');
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      return true; // Return success
    }

    window.addEventListener('resize', resizeCanvas);

    function connectWebSocket() {
      ws = new WebSocket(`ws://${window.location.host}/ws`);
      ws.onopen = () => {
        statusEl.textContent = 'Waiting for media...';
      };
      ws.onmessage = async event => {
        try {
          const data = JSON.parse(event.data);
          if (data.audio_url) await playAudio(data);
          else if (data.video_url) playVideo(data);
          else if (data.command === "pause") pauseCurrentMedia();
          else if (data.command === "stop") {
            stopCurrentMedia();
            statusEl.textContent = 'Waiting for media...';
          }
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };
      ws.onclose = () => {
        Location.reload()
        statusEl.textContent = 'Reconnecting...';
        setTimeout(connectWebSocket, 3000);
      };
      ws.onerror = error => {
        console.error('WebSocket error:', error);
        statusEl.textContent = 'Connection error';
      };
    }

    function stopCurrentMedia() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
      if (currentVideo) {
        currentVideo.pause();
        currentVideo.currentTime = 0;
        document.body.removeChild(currentVideo);
        currentVideo = null;
      }
      cancelAnimationFrame(drawLoop);
      nowPlayingEl.style.display = 'none';
      visualizer.style.visibility = 'hidden';
      document.body.classList.remove('album-art-bg');
      albumArtEl.style.display = 'none';
      titleEl.textContent = 'Waiting for media...';
      artistEl.textContent = '';
      albumArtEl.src = '';
    }

    function pauseCurrentMedia() {
      if (currentAudio) {
        currentAudio.paused ? currentAudio.play() : currentAudio.pause();
      }
      if (currentVideo) {
        currentVideo.paused ? currentVideo.play() : currentVideo.pause();
      }
    }

    async function fetchMetadata(metadataUrl) {
      try {
        const response = await fetch(metadataUrl);
        if (response.ok) {
          const data = await response.json();
          return data.metadata;
        }
      } catch (error) {
        console.error('Error fetching metadata:', error);
      }
      return null;
    }

    async function playAudio(data) {
      stopCurrentMedia();
      currentAudio = new Audio(data.audio_url);
      currentAudio.crossOrigin = "anonymous";
      currentAudio.volume = data.volume || 0.5;
      currentAudio.loop = data.loop;

      currentAudio.oncanplay = async () => {
        if (!currentAudio) {
          return;
        }
        statusEl.textContent = 'Now Playing Audio';
        nowPlayingEl.style.display = 'block';
        visualizer.style.visibility = 'visible';

        // Fetch metadata from your API
        const metadata = await fetchMetadata(data.metadata);

        if (metadata && (metadata.title || metadata.artist || metadata.album)) {
          // Remove file extension from title if present
          let title = metadata.title || 'Unknown Title';
          title = title.replace(/\.[^/.]+$/, "");

          titleEl.textContent = title;
          artistEl.textContent = metadata.artist || 'Unknown Artist';

          // Use album art from metadata or fallback to provided URL
          const albumArtUrl = metadata.albumart || data.album_art_url;
          if (albumArtUrl) {
            albumArtEl.src = albumArtUrl;
            albumArtEl.style.display = 'block';
            document.body.classList.add('album-art-bg');
          } else {
            albumArtEl.style.display = 'none';
            document.body.classList.remove('album-art-bg');
          }
        } else {
          // Fallback: show filename without extension
          let fileName = data.audio_url.split('/').pop() || data.audio_url;
          fileName = fileName.replace(/\.[^/.]+$/, "");

          titleEl.textContent = decodeURIComponent(fileName);
          artistEl.textContent = '';
          albumArtEl.style.display = 'none';
          document.body.classList.remove('album-art-bg');
        }

        if (currentAudio) {
          setupVisualizer(currentAudio);
        }
      };

      currentAudio.onended = stopCurrentMedia;
      currentAudio.onerror = e => {
        console.error('Audio error:', e);
        statusEl.textContent = 'Audio error';
        stopCurrentMedia();
      };

      currentAudio.play().catch(() => {
        statusEl.textContent = 'Audio playback requires user interaction';
      });
    }

    function setupVisualizer(audioElement) {
      if (audioCtx) audioCtx.close();
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      source = audioCtx.createMediaElementSource(audioElement);
      source.connect(analyser);
      analyser.connect(audioCtx.destination);
      analyser.fftSize = 512;
      analyser.smoothingTimeConstant = 0.8;
      dataArray = new Uint8Array(analyser.frequencyBinCount);

      // Ensure canvas is properly sized before starting visualization
      setTimeout(() => {
        if (resizeCanvas()) {
          drawVisualizer();
        }
      }, 100);
    }

    function drawVisualizer() {
      drawLoop = requestAnimationFrame(drawVisualizer);

      if (!analyser || !dataArray) return;

      analyser.getByteFrequencyData(dataArray);

      // Get fresh context reference
      const ctx = canvas.getContext('2d');
      const canvasWidth = canvas.width / window.devicePixelRatio;
      const canvasHeight = canvas.height / window.devicePixelRatio;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      const barCount = 160;
      const barWidth = canvasWidth / barCount;

      for (let i = 0; i < barCount; i++) {
        const barHeight = (dataArray[i] / 255) * canvasHeight;

        const intensity = dataArray[i] / 255;
        const lightness = 50 + intensity * 40;

        ctx.fillStyle = `hsl(0, 80%, ${100 - lightness}%)`;

        const x = i * barWidth;
        const y = canvasHeight - barHeight;

        ctx.fillRect(x, y, barWidth - 1, barHeight);
      }
    }

    function playVideo(data) {
      stopCurrentMedia();
      currentVideo = document.createElement('video');
      currentVideo.src = data.video_url;
      currentVideo.autoplay = true;
      currentVideo.controls = false;
      currentVideo.muted = false;
      currentVideo.style.position = 'fixed';
      currentVideo.style.top = '0';
      currentVideo.style.left = '0';
      currentVideo.style.width = '100%';
      currentVideo.style.height = '100%';
      currentVideo.style.zIndex = '1000';
      currentVideo.style.backgroundColor = 'black';

      document.body.appendChild(currentVideo);

      statusEl.textContent = 'Now Playing Video';
      nowPlayingEl.style.display = 'none';
      visualizer.style.visibility = 'hidden';
      albumArtEl.style.display = 'none';
      document.body.classList.remove('album-art-bg');

      currentVideo.onended = () => {
        stopCurrentMedia();
        statusEl.textContent = 'Video ended';
      };

      currentVideo.onerror = (e) => {
        console.error('Video error:', e);
        statusEl.textContent = 'Video error';
        stopCurrentMedia();
      };
    }

    connectWebSocket();

    function updateTimeDisplay() {
      const now = new Date();

      // French date format: "vendredi 1 août 2025"
      const dateOptions = {
        weekday: 'long',
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      };
      const dateStr = now.toLocaleDateString('fr-FR', dateOptions);

      // Adjust the hours by adding 2
      let hours = now.getHours() + 2;
      // Ensure that the hours wrap around correctly if they exceed 23
      if (hours >= 24) {
        hours -= 24;
      }
      const adjustedHours = hours.toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');

      const timeStr = `${adjustedHours}h${minutes} - ${seconds}s`;

      // Update the HTML elements
      const dateDisplay = document.getElementById('dateDisplay');
      const clockDisplay = document.getElementById('clockDisplay');

      if (dateDisplay && clockDisplay) {
        dateDisplay.textContent = dateStr;
        clockDisplay.textContent = timeStr;
      } else {
        console.error('Elements with IDs "dateDisplay" or "clockDisplay" not found.');
      }
    }

    // Call the function immediately and then every second
    updateTimeDisplay();
    setInterval(updateTimeDisplay, 1000);

  </script>
</body>
</html>